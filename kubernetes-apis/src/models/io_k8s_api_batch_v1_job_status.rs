/* 
 * Kubernetes
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1.13.2
 * 
 * Generated by: https://openapi-generator.tech
 */

/// IoK8sApiBatchV1JobStatus : JobStatus represents the current state of a Job.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct IoK8sApiBatchV1JobStatus {
  /// The number of actively running pods.
  #[serde(rename = "active")]
  active: Option<i32>,
  /// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
  #[serde(rename = "completionTime")]
  completion_time: Option<String>,
  /// The latest available observations of an object's current state. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  #[serde(rename = "conditions")]
  conditions: Option<Vec<::models::IoK8sApiBatchV1JobCondition>>,
  /// The number of pods which reached phase Failed.
  #[serde(rename = "failed")]
  failed: Option<i32>,
  /// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
  #[serde(rename = "startTime")]
  start_time: Option<String>,
  /// The number of pods which reached phase Succeeded.
  #[serde(rename = "succeeded")]
  succeeded: Option<i32>
}

impl IoK8sApiBatchV1JobStatus {
  /// JobStatus represents the current state of a Job.
  pub fn new() -> IoK8sApiBatchV1JobStatus {
    IoK8sApiBatchV1JobStatus {
      active: None,
      completion_time: None,
      conditions: None,
      failed: None,
      start_time: None,
      succeeded: None
    }
  }

  pub fn set_active(&mut self, active: i32) {
    self.active = Some(active);
  }

  pub fn with_active(mut self, active: i32) -> IoK8sApiBatchV1JobStatus {
    self.active = Some(active);
    self
  }

  pub fn active(&self) -> Option<&i32> {
    self.active.as_ref()
  }

  pub fn reset_active(&mut self) {
    self.active = None;
  }

  pub fn set_completion_time(&mut self, completion_time: String) {
    self.completion_time = Some(completion_time);
  }

  pub fn with_completion_time(mut self, completion_time: String) -> IoK8sApiBatchV1JobStatus {
    self.completion_time = Some(completion_time);
    self
  }

  pub fn completion_time(&self) -> Option<&String> {
    self.completion_time.as_ref()
  }

  pub fn reset_completion_time(&mut self) {
    self.completion_time = None;
  }

  pub fn set_conditions(&mut self, conditions: Vec<::models::IoK8sApiBatchV1JobCondition>) {
    self.conditions = Some(conditions);
  }

  pub fn with_conditions(mut self, conditions: Vec<::models::IoK8sApiBatchV1JobCondition>) -> IoK8sApiBatchV1JobStatus {
    self.conditions = Some(conditions);
    self
  }

  pub fn conditions(&self) -> Option<&Vec<::models::IoK8sApiBatchV1JobCondition>> {
    self.conditions.as_ref()
  }

  pub fn reset_conditions(&mut self) {
    self.conditions = None;
  }

  pub fn set_failed(&mut self, failed: i32) {
    self.failed = Some(failed);
  }

  pub fn with_failed(mut self, failed: i32) -> IoK8sApiBatchV1JobStatus {
    self.failed = Some(failed);
    self
  }

  pub fn failed(&self) -> Option<&i32> {
    self.failed.as_ref()
  }

  pub fn reset_failed(&mut self) {
    self.failed = None;
  }

  pub fn set_start_time(&mut self, start_time: String) {
    self.start_time = Some(start_time);
  }

  pub fn with_start_time(mut self, start_time: String) -> IoK8sApiBatchV1JobStatus {
    self.start_time = Some(start_time);
    self
  }

  pub fn start_time(&self) -> Option<&String> {
    self.start_time.as_ref()
  }

  pub fn reset_start_time(&mut self) {
    self.start_time = None;
  }

  pub fn set_succeeded(&mut self, succeeded: i32) {
    self.succeeded = Some(succeeded);
  }

  pub fn with_succeeded(mut self, succeeded: i32) -> IoK8sApiBatchV1JobStatus {
    self.succeeded = Some(succeeded);
    self
  }

  pub fn succeeded(&self) -> Option<&i32> {
    self.succeeded.as_ref()
  }

  pub fn reset_succeeded(&mut self) {
    self.succeeded = None;
  }

}



