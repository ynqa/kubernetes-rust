/* 
 * Kubernetes
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1.13.2
 * 
 * Generated by: https://openapi-generator.tech
 */

/// IoK8sApiCoreV1PersistentVolumeSpec : PersistentVolumeSpec is the specification of a persistent volume.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct IoK8sApiCoreV1PersistentVolumeSpec {
  /// AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
  #[serde(rename = "accessModes")]
  access_modes: Option<Vec<String>>,
  #[serde(rename = "awsElasticBlockStore")]
  aws_elastic_block_store: Option<::models::IoK8sApiCoreV1AwsElasticBlockStoreVolumeSource>,
  #[serde(rename = "azureDisk")]
  azure_disk: Option<::models::IoK8sApiCoreV1AzureDiskVolumeSource>,
  #[serde(rename = "azureFile")]
  azure_file: Option<::models::IoK8sApiCoreV1AzureFilePersistentVolumeSource>,
  /// A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
  #[serde(rename = "capacity")]
  capacity: Option<::std::collections::HashMap<String, String>>,
  #[serde(rename = "cephfs")]
  cephfs: Option<::models::IoK8sApiCoreV1CephFsPersistentVolumeSource>,
  #[serde(rename = "cinder")]
  cinder: Option<::models::IoK8sApiCoreV1CinderPersistentVolumeSource>,
  #[serde(rename = "claimRef")]
  claim_ref: Option<::models::IoK8sApiCoreV1ObjectReference>,
  #[serde(rename = "csi")]
  csi: Option<::models::IoK8sApiCoreV1CsiPersistentVolumeSource>,
  #[serde(rename = "fc")]
  fc: Option<::models::IoK8sApiCoreV1FcVolumeSource>,
  #[serde(rename = "flexVolume")]
  flex_volume: Option<::models::IoK8sApiCoreV1FlexPersistentVolumeSource>,
  #[serde(rename = "flocker")]
  flocker: Option<::models::IoK8sApiCoreV1FlockerVolumeSource>,
  #[serde(rename = "gcePersistentDisk")]
  gce_persistent_disk: Option<::models::IoK8sApiCoreV1GcePersistentDiskVolumeSource>,
  #[serde(rename = "glusterfs")]
  glusterfs: Option<::models::IoK8sApiCoreV1GlusterfsPersistentVolumeSource>,
  #[serde(rename = "hostPath")]
  host_path: Option<::models::IoK8sApiCoreV1HostPathVolumeSource>,
  #[serde(rename = "iscsi")]
  iscsi: Option<::models::IoK8sApiCoreV1IscsiPersistentVolumeSource>,
  #[serde(rename = "local")]
  local: Option<::models::IoK8sApiCoreV1LocalVolumeSource>,
  /// A list of mount options, e.g. [\"ro\", \"soft\"]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
  #[serde(rename = "mountOptions")]
  mount_options: Option<Vec<String>>,
  #[serde(rename = "nfs")]
  nfs: Option<::models::IoK8sApiCoreV1NfsVolumeSource>,
  #[serde(rename = "nodeAffinity")]
  node_affinity: Option<::models::IoK8sApiCoreV1VolumeNodeAffinity>,
  /// What happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
  #[serde(rename = "persistentVolumeReclaimPolicy")]
  persistent_volume_reclaim_policy: Option<String>,
  #[serde(rename = "photonPersistentDisk")]
  photon_persistent_disk: Option<::models::IoK8sApiCoreV1PhotonPersistentDiskVolumeSource>,
  #[serde(rename = "portworxVolume")]
  portworx_volume: Option<::models::IoK8sApiCoreV1PortworxVolumeSource>,
  #[serde(rename = "quobyte")]
  quobyte: Option<::models::IoK8sApiCoreV1QuobyteVolumeSource>,
  #[serde(rename = "rbd")]
  rbd: Option<::models::IoK8sApiCoreV1RbdPersistentVolumeSource>,
  #[serde(rename = "scaleIO")]
  scale_io: Option<::models::IoK8sApiCoreV1ScaleIoPersistentVolumeSource>,
  /// Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.
  #[serde(rename = "storageClassName")]
  storage_class_name: Option<String>,
  #[serde(rename = "storageos")]
  storageos: Option<::models::IoK8sApiCoreV1StorageOsPersistentVolumeSource>,
  /// volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec. This is a beta feature.
  #[serde(rename = "volumeMode")]
  volume_mode: Option<String>,
  #[serde(rename = "vsphereVolume")]
  vsphere_volume: Option<::models::IoK8sApiCoreV1VsphereVirtualDiskVolumeSource>
}

impl IoK8sApiCoreV1PersistentVolumeSpec {
  /// PersistentVolumeSpec is the specification of a persistent volume.
  pub fn new() -> IoK8sApiCoreV1PersistentVolumeSpec {
    IoK8sApiCoreV1PersistentVolumeSpec {
      access_modes: None,
      aws_elastic_block_store: None,
      azure_disk: None,
      azure_file: None,
      capacity: None,
      cephfs: None,
      cinder: None,
      claim_ref: None,
      csi: None,
      fc: None,
      flex_volume: None,
      flocker: None,
      gce_persistent_disk: None,
      glusterfs: None,
      host_path: None,
      iscsi: None,
      local: None,
      mount_options: None,
      nfs: None,
      node_affinity: None,
      persistent_volume_reclaim_policy: None,
      photon_persistent_disk: None,
      portworx_volume: None,
      quobyte: None,
      rbd: None,
      scale_io: None,
      storage_class_name: None,
      storageos: None,
      volume_mode: None,
      vsphere_volume: None
    }
  }

  pub fn set_access_modes(&mut self, access_modes: Vec<String>) {
    self.access_modes = Some(access_modes);
  }

  pub fn with_access_modes(mut self, access_modes: Vec<String>) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.access_modes = Some(access_modes);
    self
  }

  pub fn access_modes(&self) -> Option<&Vec<String>> {
    self.access_modes.as_ref()
  }

  pub fn reset_access_modes(&mut self) {
    self.access_modes = None;
  }

  pub fn set_aws_elastic_block_store(&mut self, aws_elastic_block_store: ::models::IoK8sApiCoreV1AwsElasticBlockStoreVolumeSource) {
    self.aws_elastic_block_store = Some(aws_elastic_block_store);
  }

  pub fn with_aws_elastic_block_store(mut self, aws_elastic_block_store: ::models::IoK8sApiCoreV1AwsElasticBlockStoreVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.aws_elastic_block_store = Some(aws_elastic_block_store);
    self
  }

  pub fn aws_elastic_block_store(&self) -> Option<&::models::IoK8sApiCoreV1AwsElasticBlockStoreVolumeSource> {
    self.aws_elastic_block_store.as_ref()
  }

  pub fn reset_aws_elastic_block_store(&mut self) {
    self.aws_elastic_block_store = None;
  }

  pub fn set_azure_disk(&mut self, azure_disk: ::models::IoK8sApiCoreV1AzureDiskVolumeSource) {
    self.azure_disk = Some(azure_disk);
  }

  pub fn with_azure_disk(mut self, azure_disk: ::models::IoK8sApiCoreV1AzureDiskVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.azure_disk = Some(azure_disk);
    self
  }

  pub fn azure_disk(&self) -> Option<&::models::IoK8sApiCoreV1AzureDiskVolumeSource> {
    self.azure_disk.as_ref()
  }

  pub fn reset_azure_disk(&mut self) {
    self.azure_disk = None;
  }

  pub fn set_azure_file(&mut self, azure_file: ::models::IoK8sApiCoreV1AzureFilePersistentVolumeSource) {
    self.azure_file = Some(azure_file);
  }

  pub fn with_azure_file(mut self, azure_file: ::models::IoK8sApiCoreV1AzureFilePersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.azure_file = Some(azure_file);
    self
  }

  pub fn azure_file(&self) -> Option<&::models::IoK8sApiCoreV1AzureFilePersistentVolumeSource> {
    self.azure_file.as_ref()
  }

  pub fn reset_azure_file(&mut self) {
    self.azure_file = None;
  }

  pub fn set_capacity(&mut self, capacity: ::std::collections::HashMap<String, String>) {
    self.capacity = Some(capacity);
  }

  pub fn with_capacity(mut self, capacity: ::std::collections::HashMap<String, String>) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.capacity = Some(capacity);
    self
  }

  pub fn capacity(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.capacity.as_ref()
  }

  pub fn reset_capacity(&mut self) {
    self.capacity = None;
  }

  pub fn set_cephfs(&mut self, cephfs: ::models::IoK8sApiCoreV1CephFsPersistentVolumeSource) {
    self.cephfs = Some(cephfs);
  }

  pub fn with_cephfs(mut self, cephfs: ::models::IoK8sApiCoreV1CephFsPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.cephfs = Some(cephfs);
    self
  }

  pub fn cephfs(&self) -> Option<&::models::IoK8sApiCoreV1CephFsPersistentVolumeSource> {
    self.cephfs.as_ref()
  }

  pub fn reset_cephfs(&mut self) {
    self.cephfs = None;
  }

  pub fn set_cinder(&mut self, cinder: ::models::IoK8sApiCoreV1CinderPersistentVolumeSource) {
    self.cinder = Some(cinder);
  }

  pub fn with_cinder(mut self, cinder: ::models::IoK8sApiCoreV1CinderPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.cinder = Some(cinder);
    self
  }

  pub fn cinder(&self) -> Option<&::models::IoK8sApiCoreV1CinderPersistentVolumeSource> {
    self.cinder.as_ref()
  }

  pub fn reset_cinder(&mut self) {
    self.cinder = None;
  }

  pub fn set_claim_ref(&mut self, claim_ref: ::models::IoK8sApiCoreV1ObjectReference) {
    self.claim_ref = Some(claim_ref);
  }

  pub fn with_claim_ref(mut self, claim_ref: ::models::IoK8sApiCoreV1ObjectReference) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.claim_ref = Some(claim_ref);
    self
  }

  pub fn claim_ref(&self) -> Option<&::models::IoK8sApiCoreV1ObjectReference> {
    self.claim_ref.as_ref()
  }

  pub fn reset_claim_ref(&mut self) {
    self.claim_ref = None;
  }

  pub fn set_csi(&mut self, csi: ::models::IoK8sApiCoreV1CsiPersistentVolumeSource) {
    self.csi = Some(csi);
  }

  pub fn with_csi(mut self, csi: ::models::IoK8sApiCoreV1CsiPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.csi = Some(csi);
    self
  }

  pub fn csi(&self) -> Option<&::models::IoK8sApiCoreV1CsiPersistentVolumeSource> {
    self.csi.as_ref()
  }

  pub fn reset_csi(&mut self) {
    self.csi = None;
  }

  pub fn set_fc(&mut self, fc: ::models::IoK8sApiCoreV1FcVolumeSource) {
    self.fc = Some(fc);
  }

  pub fn with_fc(mut self, fc: ::models::IoK8sApiCoreV1FcVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.fc = Some(fc);
    self
  }

  pub fn fc(&self) -> Option<&::models::IoK8sApiCoreV1FcVolumeSource> {
    self.fc.as_ref()
  }

  pub fn reset_fc(&mut self) {
    self.fc = None;
  }

  pub fn set_flex_volume(&mut self, flex_volume: ::models::IoK8sApiCoreV1FlexPersistentVolumeSource) {
    self.flex_volume = Some(flex_volume);
  }

  pub fn with_flex_volume(mut self, flex_volume: ::models::IoK8sApiCoreV1FlexPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.flex_volume = Some(flex_volume);
    self
  }

  pub fn flex_volume(&self) -> Option<&::models::IoK8sApiCoreV1FlexPersistentVolumeSource> {
    self.flex_volume.as_ref()
  }

  pub fn reset_flex_volume(&mut self) {
    self.flex_volume = None;
  }

  pub fn set_flocker(&mut self, flocker: ::models::IoK8sApiCoreV1FlockerVolumeSource) {
    self.flocker = Some(flocker);
  }

  pub fn with_flocker(mut self, flocker: ::models::IoK8sApiCoreV1FlockerVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.flocker = Some(flocker);
    self
  }

  pub fn flocker(&self) -> Option<&::models::IoK8sApiCoreV1FlockerVolumeSource> {
    self.flocker.as_ref()
  }

  pub fn reset_flocker(&mut self) {
    self.flocker = None;
  }

  pub fn set_gce_persistent_disk(&mut self, gce_persistent_disk: ::models::IoK8sApiCoreV1GcePersistentDiskVolumeSource) {
    self.gce_persistent_disk = Some(gce_persistent_disk);
  }

  pub fn with_gce_persistent_disk(mut self, gce_persistent_disk: ::models::IoK8sApiCoreV1GcePersistentDiskVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.gce_persistent_disk = Some(gce_persistent_disk);
    self
  }

  pub fn gce_persistent_disk(&self) -> Option<&::models::IoK8sApiCoreV1GcePersistentDiskVolumeSource> {
    self.gce_persistent_disk.as_ref()
  }

  pub fn reset_gce_persistent_disk(&mut self) {
    self.gce_persistent_disk = None;
  }

  pub fn set_glusterfs(&mut self, glusterfs: ::models::IoK8sApiCoreV1GlusterfsPersistentVolumeSource) {
    self.glusterfs = Some(glusterfs);
  }

  pub fn with_glusterfs(mut self, glusterfs: ::models::IoK8sApiCoreV1GlusterfsPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.glusterfs = Some(glusterfs);
    self
  }

  pub fn glusterfs(&self) -> Option<&::models::IoK8sApiCoreV1GlusterfsPersistentVolumeSource> {
    self.glusterfs.as_ref()
  }

  pub fn reset_glusterfs(&mut self) {
    self.glusterfs = None;
  }

  pub fn set_host_path(&mut self, host_path: ::models::IoK8sApiCoreV1HostPathVolumeSource) {
    self.host_path = Some(host_path);
  }

  pub fn with_host_path(mut self, host_path: ::models::IoK8sApiCoreV1HostPathVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.host_path = Some(host_path);
    self
  }

  pub fn host_path(&self) -> Option<&::models::IoK8sApiCoreV1HostPathVolumeSource> {
    self.host_path.as_ref()
  }

  pub fn reset_host_path(&mut self) {
    self.host_path = None;
  }

  pub fn set_iscsi(&mut self, iscsi: ::models::IoK8sApiCoreV1IscsiPersistentVolumeSource) {
    self.iscsi = Some(iscsi);
  }

  pub fn with_iscsi(mut self, iscsi: ::models::IoK8sApiCoreV1IscsiPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.iscsi = Some(iscsi);
    self
  }

  pub fn iscsi(&self) -> Option<&::models::IoK8sApiCoreV1IscsiPersistentVolumeSource> {
    self.iscsi.as_ref()
  }

  pub fn reset_iscsi(&mut self) {
    self.iscsi = None;
  }

  pub fn set_local(&mut self, local: ::models::IoK8sApiCoreV1LocalVolumeSource) {
    self.local = Some(local);
  }

  pub fn with_local(mut self, local: ::models::IoK8sApiCoreV1LocalVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.local = Some(local);
    self
  }

  pub fn local(&self) -> Option<&::models::IoK8sApiCoreV1LocalVolumeSource> {
    self.local.as_ref()
  }

  pub fn reset_local(&mut self) {
    self.local = None;
  }

  pub fn set_mount_options(&mut self, mount_options: Vec<String>) {
    self.mount_options = Some(mount_options);
  }

  pub fn with_mount_options(mut self, mount_options: Vec<String>) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.mount_options = Some(mount_options);
    self
  }

  pub fn mount_options(&self) -> Option<&Vec<String>> {
    self.mount_options.as_ref()
  }

  pub fn reset_mount_options(&mut self) {
    self.mount_options = None;
  }

  pub fn set_nfs(&mut self, nfs: ::models::IoK8sApiCoreV1NfsVolumeSource) {
    self.nfs = Some(nfs);
  }

  pub fn with_nfs(mut self, nfs: ::models::IoK8sApiCoreV1NfsVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.nfs = Some(nfs);
    self
  }

  pub fn nfs(&self) -> Option<&::models::IoK8sApiCoreV1NfsVolumeSource> {
    self.nfs.as_ref()
  }

  pub fn reset_nfs(&mut self) {
    self.nfs = None;
  }

  pub fn set_node_affinity(&mut self, node_affinity: ::models::IoK8sApiCoreV1VolumeNodeAffinity) {
    self.node_affinity = Some(node_affinity);
  }

  pub fn with_node_affinity(mut self, node_affinity: ::models::IoK8sApiCoreV1VolumeNodeAffinity) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.node_affinity = Some(node_affinity);
    self
  }

  pub fn node_affinity(&self) -> Option<&::models::IoK8sApiCoreV1VolumeNodeAffinity> {
    self.node_affinity.as_ref()
  }

  pub fn reset_node_affinity(&mut self) {
    self.node_affinity = None;
  }

  pub fn set_persistent_volume_reclaim_policy(&mut self, persistent_volume_reclaim_policy: String) {
    self.persistent_volume_reclaim_policy = Some(persistent_volume_reclaim_policy);
  }

  pub fn with_persistent_volume_reclaim_policy(mut self, persistent_volume_reclaim_policy: String) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.persistent_volume_reclaim_policy = Some(persistent_volume_reclaim_policy);
    self
  }

  pub fn persistent_volume_reclaim_policy(&self) -> Option<&String> {
    self.persistent_volume_reclaim_policy.as_ref()
  }

  pub fn reset_persistent_volume_reclaim_policy(&mut self) {
    self.persistent_volume_reclaim_policy = None;
  }

  pub fn set_photon_persistent_disk(&mut self, photon_persistent_disk: ::models::IoK8sApiCoreV1PhotonPersistentDiskVolumeSource) {
    self.photon_persistent_disk = Some(photon_persistent_disk);
  }

  pub fn with_photon_persistent_disk(mut self, photon_persistent_disk: ::models::IoK8sApiCoreV1PhotonPersistentDiskVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.photon_persistent_disk = Some(photon_persistent_disk);
    self
  }

  pub fn photon_persistent_disk(&self) -> Option<&::models::IoK8sApiCoreV1PhotonPersistentDiskVolumeSource> {
    self.photon_persistent_disk.as_ref()
  }

  pub fn reset_photon_persistent_disk(&mut self) {
    self.photon_persistent_disk = None;
  }

  pub fn set_portworx_volume(&mut self, portworx_volume: ::models::IoK8sApiCoreV1PortworxVolumeSource) {
    self.portworx_volume = Some(portworx_volume);
  }

  pub fn with_portworx_volume(mut self, portworx_volume: ::models::IoK8sApiCoreV1PortworxVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.portworx_volume = Some(portworx_volume);
    self
  }

  pub fn portworx_volume(&self) -> Option<&::models::IoK8sApiCoreV1PortworxVolumeSource> {
    self.portworx_volume.as_ref()
  }

  pub fn reset_portworx_volume(&mut self) {
    self.portworx_volume = None;
  }

  pub fn set_quobyte(&mut self, quobyte: ::models::IoK8sApiCoreV1QuobyteVolumeSource) {
    self.quobyte = Some(quobyte);
  }

  pub fn with_quobyte(mut self, quobyte: ::models::IoK8sApiCoreV1QuobyteVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.quobyte = Some(quobyte);
    self
  }

  pub fn quobyte(&self) -> Option<&::models::IoK8sApiCoreV1QuobyteVolumeSource> {
    self.quobyte.as_ref()
  }

  pub fn reset_quobyte(&mut self) {
    self.quobyte = None;
  }

  pub fn set_rbd(&mut self, rbd: ::models::IoK8sApiCoreV1RbdPersistentVolumeSource) {
    self.rbd = Some(rbd);
  }

  pub fn with_rbd(mut self, rbd: ::models::IoK8sApiCoreV1RbdPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.rbd = Some(rbd);
    self
  }

  pub fn rbd(&self) -> Option<&::models::IoK8sApiCoreV1RbdPersistentVolumeSource> {
    self.rbd.as_ref()
  }

  pub fn reset_rbd(&mut self) {
    self.rbd = None;
  }

  pub fn set_scale_io(&mut self, scale_io: ::models::IoK8sApiCoreV1ScaleIoPersistentVolumeSource) {
    self.scale_io = Some(scale_io);
  }

  pub fn with_scale_io(mut self, scale_io: ::models::IoK8sApiCoreV1ScaleIoPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.scale_io = Some(scale_io);
    self
  }

  pub fn scale_io(&self) -> Option<&::models::IoK8sApiCoreV1ScaleIoPersistentVolumeSource> {
    self.scale_io.as_ref()
  }

  pub fn reset_scale_io(&mut self) {
    self.scale_io = None;
  }

  pub fn set_storage_class_name(&mut self, storage_class_name: String) {
    self.storage_class_name = Some(storage_class_name);
  }

  pub fn with_storage_class_name(mut self, storage_class_name: String) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.storage_class_name = Some(storage_class_name);
    self
  }

  pub fn storage_class_name(&self) -> Option<&String> {
    self.storage_class_name.as_ref()
  }

  pub fn reset_storage_class_name(&mut self) {
    self.storage_class_name = None;
  }

  pub fn set_storageos(&mut self, storageos: ::models::IoK8sApiCoreV1StorageOsPersistentVolumeSource) {
    self.storageos = Some(storageos);
  }

  pub fn with_storageos(mut self, storageos: ::models::IoK8sApiCoreV1StorageOsPersistentVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.storageos = Some(storageos);
    self
  }

  pub fn storageos(&self) -> Option<&::models::IoK8sApiCoreV1StorageOsPersistentVolumeSource> {
    self.storageos.as_ref()
  }

  pub fn reset_storageos(&mut self) {
    self.storageos = None;
  }

  pub fn set_volume_mode(&mut self, volume_mode: String) {
    self.volume_mode = Some(volume_mode);
  }

  pub fn with_volume_mode(mut self, volume_mode: String) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.volume_mode = Some(volume_mode);
    self
  }

  pub fn volume_mode(&self) -> Option<&String> {
    self.volume_mode.as_ref()
  }

  pub fn reset_volume_mode(&mut self) {
    self.volume_mode = None;
  }

  pub fn set_vsphere_volume(&mut self, vsphere_volume: ::models::IoK8sApiCoreV1VsphereVirtualDiskVolumeSource) {
    self.vsphere_volume = Some(vsphere_volume);
  }

  pub fn with_vsphere_volume(mut self, vsphere_volume: ::models::IoK8sApiCoreV1VsphereVirtualDiskVolumeSource) -> IoK8sApiCoreV1PersistentVolumeSpec {
    self.vsphere_volume = Some(vsphere_volume);
    self
  }

  pub fn vsphere_volume(&self) -> Option<&::models::IoK8sApiCoreV1VsphereVirtualDiskVolumeSource> {
    self.vsphere_volume.as_ref()
  }

  pub fn reset_vsphere_volume(&mut self) {
    self.vsphere_volume = None;
  }

}



