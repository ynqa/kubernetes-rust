/* 
 * Kubernetes
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1.13.2
 * 
 * Generated by: https://openapi-generator.tech
 */

/// IoK8sApiCoreV1PersistentVolumeClaimStatus : PersistentVolumeClaimStatus is the current status of a persistent volume claim.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct IoK8sApiCoreV1PersistentVolumeClaimStatus {
  /// AccessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  #[serde(rename = "accessModes")]
  access_modes: Option<Vec<String>>,
  /// Represents the actual resources of the underlying volume.
  #[serde(rename = "capacity")]
  capacity: Option<::std::collections::HashMap<String, String>>,
  /// Current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
  #[serde(rename = "conditions")]
  conditions: Option<Vec<::models::IoK8sApiCoreV1PersistentVolumeClaimCondition>>,
  /// Phase represents the current phase of PersistentVolumeClaim.
  #[serde(rename = "phase")]
  phase: Option<String>
}

impl IoK8sApiCoreV1PersistentVolumeClaimStatus {
  /// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
  pub fn new() -> IoK8sApiCoreV1PersistentVolumeClaimStatus {
    IoK8sApiCoreV1PersistentVolumeClaimStatus {
      access_modes: None,
      capacity: None,
      conditions: None,
      phase: None
    }
  }

  pub fn set_access_modes(&mut self, access_modes: Vec<String>) {
    self.access_modes = Some(access_modes);
  }

  pub fn with_access_modes(mut self, access_modes: Vec<String>) -> IoK8sApiCoreV1PersistentVolumeClaimStatus {
    self.access_modes = Some(access_modes);
    self
  }

  pub fn access_modes(&self) -> Option<&Vec<String>> {
    self.access_modes.as_ref()
  }

  pub fn reset_access_modes(&mut self) {
    self.access_modes = None;
  }

  pub fn set_capacity(&mut self, capacity: ::std::collections::HashMap<String, String>) {
    self.capacity = Some(capacity);
  }

  pub fn with_capacity(mut self, capacity: ::std::collections::HashMap<String, String>) -> IoK8sApiCoreV1PersistentVolumeClaimStatus {
    self.capacity = Some(capacity);
    self
  }

  pub fn capacity(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.capacity.as_ref()
  }

  pub fn reset_capacity(&mut self) {
    self.capacity = None;
  }

  pub fn set_conditions(&mut self, conditions: Vec<::models::IoK8sApiCoreV1PersistentVolumeClaimCondition>) {
    self.conditions = Some(conditions);
  }

  pub fn with_conditions(mut self, conditions: Vec<::models::IoK8sApiCoreV1PersistentVolumeClaimCondition>) -> IoK8sApiCoreV1PersistentVolumeClaimStatus {
    self.conditions = Some(conditions);
    self
  }

  pub fn conditions(&self) -> Option<&Vec<::models::IoK8sApiCoreV1PersistentVolumeClaimCondition>> {
    self.conditions.as_ref()
  }

  pub fn reset_conditions(&mut self) {
    self.conditions = None;
  }

  pub fn set_phase(&mut self, phase: String) {
    self.phase = Some(phase);
  }

  pub fn with_phase(mut self, phase: String) -> IoK8sApiCoreV1PersistentVolumeClaimStatus {
    self.phase = Some(phase);
    self
  }

  pub fn phase(&self) -> Option<&String> {
    self.phase.as_ref()
  }

  pub fn reset_phase(&mut self) {
    self.phase = None;
  }

}



